<!DOCTYPE html>
<html lang="zh-tw">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, mainial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <title>Taiwan Typhoon Day Off Status</title>
  <meta property="og:description" content="A map of Taiwan to show where is dayoff">
  <meta property="og:title" content="Taiwan Typhoon Day Off Status">
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    .marker {
      border-radius: 5px;
    }
  </style>
</head>

<body style="margin: 0;padding: 0">
  <div id="map" style="height: 100dvh; overflow:hidden;background-color: rgb(63, 63, 63);"></div>
  <p id="lastupdate" style="position: absolute; font-size: large; top:0;right: 2rem;color:white;z-index:9999;"></p>

  <!-- é¢±é¢¨è³‡æ–™ç›£æ¸¬é¢æ¿ -->
  <div id="typhoon-debug"
    style="position: absolute; top: 10px; left: 10px; background-color: rgba(53, 53, 53, 0.8); padding: 0.75rem; border-radius: 15px; max-width: 300px; max-height: 80vh; overflow-y: auto; z-index: 10000; color: white;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
      <strong style="font-size: 14px;">ğŸŒ€ é¢±é¢¨è³‡æ–™ç›£æ§</strong>
      <button id="toggle-debug"
        style="cursor: pointer; padding: 5px 10px; border: none; background-color: gray; color: white; border-radius: 20px; user-select: none;">éš±è—</button>
    </div>
    <div id="typhoon-info" style="white-space: pre-wrap; word-break: break-word; font-size: 14px;">è¼‰å…¥ä¸­...</div>
  </div>

  <div
    style="display:flex;flex-direction:column;position: absolute;bottom: 0;margin: 0.5rem;outline:solid rgb(20, 20, 20);;background-color: rgba(53, 53, 53,0.8);border-radius: 15px;;padding: 0.75rem;color: white;z-index:9999;">

    <div
      style="display: flex; flex-direction: row;align-items: center;justify-content: center;border-radius: 20px;background-color: gray;">
      <input type="checkbox" name="Toggle" id="toggle" hidden>
      <label for="toggle" style="cursor: pointer;user-select: none;">{{changeDisplay}}</label>
    </div>
    <p id="show-info">{{currentDisplayed}} : {{work}}</p>
    <div style="display: flex;position: relative;align-items: center;">
      <div style="padding: 0.5rem;background-color: purple;"></div>
      <p>{{yourPosition}}</p>
    </div>
    <div style="display: flex;"></div>
    <div style="display: flex;position: relative;align-items: center;">
      <div style="padding: 0.5rem;background-color: yellow;"></div>
      <p>{{tomorrowDayOff}}</p>
    </div>
    <div style="display: flex;position: relative;align-items: center;">
      <div style="padding: 0.5rem;background-color: blue;"></div>
      <p>{{todayDayOff}}</p>
    </div>
    <div style="display: flex;position: relative;align-items: center;">
      <div style="padding: 0.5rem;background-color: red;"></div>
      <p>{{bothDayOff}}</p>
    </div>
    <div style="display: flex;position: relative;align-items: center;">
      <div style="padding: 0.5rem;background-color: gray;"></div>
      <p>{{noDayOff}}</p>
    </div>
  </div>

  </button>
  <script>
    let map = L.map('map').setView([23.97565, 120.9738819], 8);
    let TyphoonCounties = []
    let TyphoonTowns = []
    let TyphoonPlaces = []
    let lastupdate = document.getElementById('lastupdate');
    let showInfo = document.getElementById('show-info');
    let toggle = document.getElementById('toggle');

    let ColorMap = new Map([
      ['tomorrow', 'yellow'],
      ['today', 'blue'],
      ['some', 'green'],
      ['both', 'red'],
      ['false', 'gray']
    ])

    let main = (async () => {
      let twTown = await (await fetch(`${window.location.origin}/api/geoJson/town`)).json()
      let GeoJson = L.geoJSON(twTown, {
        style: function (feature) {
          return {
            color: 'gray',
            fillColor: 'white',
            fill: false,
            weight: 0.5,
          };
        }
      }).bindPopup((layer) => {
        return layer.feature.properties.TOWNNAME;
      });

      let PointLayer = L.layerGroup()
      let UserLocation = null;

      let type = 'work'

      const update = () => {
        PointLayer.clearLayers()
        console.log('----update----')
        console.log(TyphoonCounties)
        console.log(TyphoonTowns)
        console.log(TyphoonPlaces)
        console.log('----update----')

        //user Position Mark

        if ("geolocation" in navigator) {
          if (UserLocation) {
            L.marker(UserLocation, {
              icon: L.divIcon({
                html: `<div style="width:100%;height:100%;background-color:purple;border-radius:5px"></div>`,
                className: 'marker',
                iconSize: [10, 10],
                iconAnchor: [10, 10],
                popupAnchor: [-5, -10]
              })
            }).addTo(PointLayer).bindPopup('{{yourPosition}}').openPopup()
          } else {
            navigator.geolocation.getCurrentPosition((position) => {
              UserLocation = [position.coords.latitude, position.coords.longitude];
              L.marker(UserLocation, {
                icon: L.divIcon({
                  html: `<div style="width:100%;height:100%;background-color:purple;border-radius:5px"></div>`,
                  className: 'marker',
                  iconSize: [10, 10],
                  iconAnchor: [10, 10],
                  popupAnchor: [-5, -10]
                })
              }).addTo(PointLayer).bindPopup('{{yourPosition}}').openPopup()
            })
          }
        }

        TyphoonPlaces.forEach((place) => {
          const marker = L.marker(place.position, {
            icon: L.divIcon({
              html: `<div style="width:100%;height:100%;background-color:${ColorMap.get(place.type)};border-radius:5px"></div>`,
              className: 'marker',
              iconSize: [10, 10],
              iconAnchor: [10, 10],
              popupAnchor: [-5, -10]
            })
          }).addTo(PointLayer).bindPopup(place.name)
        })

        GeoJson.eachLayer((layer) => {
          const TownDayOffData = TyphoonTowns.find((town) => town.name === layer.feature.properties.TOWNNAME)
          if (TownDayOffData) {
            return layer.setStyle({
              color: 'gray',
              fillColor: ColorMap.get(TownDayOffData.type),
              fill: true
            })
          }

          const countyDayOffData = TyphoonCounties.find((county) => county.county === layer.feature.properties.COUNTYNAME)
          if (countyDayOffData) {
            return layer.setStyle({
              color: 'gray',
              fillColor: ColorMap.get(countyDayOffData.type),
              fill: true
            })
          }
          return layer.setStyle({
            color: 'gray',
            fillColor: 'gray',
            fill: true
          })
        })
      }

      GeoJson.addTo(map);
      PointLayer.addTo(map);
      const getDayOffType = (data) => {
        if (data?.today === true && data?.tomorrow === true) return 'both'
        if (data?.today === true) return 'today'
        if (data?.tomorrow === true) return 'tomorrow'
        return 'false'
      }
      const sleep = (time) => new Promise((resolve) => setTimeout(resolve, 1000 * time));
      const updateDataFromBackend = (() => {
        let lastUpdateTime = Infinity;
        return async () => {
          if (lastUpdateTime - new Date().getTime() < 1000 * 60) {
            return () => { };
          }
          lastUpdateTime = new Date().getTime();

          const req = (await (await fetch(`${window.location.origin}/api/typhoon`)).json())
          const data = req.data
          const isTyphoon = req.typhoon
          const time = req.time
          if (isTyphoon === false) {
            TyphoonCounties = []
            TyphoonTowns = []
            TyphoonPlaces = []
          }
          if (isTyphoon === true) {
            TyphoonCounties = data.filter((county) => Object.values(county.isDayOff).some(v => v)).map((county) => {
              const dayOffStatus = county.isDayOff[type]
              return {
                county: county.countyName,
                type: getDayOffType(dayOffStatus)
              }
            })
            const Places = data.map((county) => county.place).flat()
            TyphoonTowns = Places.filter((place) => !place.isPosition).map((place) => {
              const dayOffStatus = place.isDayOff[type]
              return {
                name: place.placeName,
                type: getDayOffType(dayOffStatus)
              }
            })
            TyphoonPlaces = Places.filter((place) => place.isPosition).map((place) => {
              const dayOffStatus = place.isDayOff[type]
              return {
                name: place.placeName,
                type: getDayOffType(dayOffStatus),
                position: place.position
              }
            })

          }
          update()
          lastupdate.innerHTML = ` {{lastUpdate}} : ${new Date(time).toLocaleDateString()} ${new Date(time).toLocaleTimeString()}`
          console.log('update')
          return;
        }
      })();



      toggle.addEventListener('change', () => {
        if (toggle.checked) {
          type = 'school'
          showInfo.innerHTML = '{{currentDisplayed}} : {{school}}'
        } else {
          type = 'work'
          showInfo.innerHTML = '{{currentDisplayed}} : {{work}}'
        }
        updateDataFromBackend()
      })

      while (true) {
        try {
          await updateDataFromBackend()
        } catch (e) {
          console.error(e)
        }
        await sleep(60)
      }
    })
    main()
    document.querySelector('div.leaflet-control-container').style.display = 'none'

    // é¢±é¢¨è·¯å¾‘é¡¯ç¤ºåŠŸèƒ½ - å®Œå…¨æ‰“åŒ…çš„å¯¦ä½œ
    const initializeTyphoonPathDisplay = (() => {
      // æ‰€æœ‰è®Šæ•¸å’Œå‡½æ•¸éƒ½å°è£åœ¨é€™å€‹ IIFE ä¸­
      let typhoonLayers = L.layerGroup();
      let isInitialized = false;
      const debugPanel = document.getElementById('typhoon-info');
      const toggleBtn = document.getElementById('toggle-debug');
      const debugContainer = document.getElementById('typhoon-debug');

      // åˆ‡æ›èª¿è©¦é¢æ¿é¡¯ç¤º/éš±è—
      toggleBtn.addEventListener('click', () => {
        const infoDiv = document.getElementById('typhoon-info');
        if (infoDiv.style.display === 'none') {
          infoDiv.style.display = 'block';
          toggleBtn.textContent = 'éš±è—';
        } else {
          infoDiv.style.display = 'none';
          toggleBtn.textContent = 'é¡¯ç¤º';
        }
      });

      // æ›´æ–°èª¿è©¦è³‡è¨Š
      const updateDebugInfo = (info) => {
        debugPanel.innerHTML = info;
      };

      // æ–¹å‘è§’åº¦è½‰æ›
      const directionToDegrees = (dir) => {
        const directions = {
          'N': 0, 'NNE': 22.5, 'NE': 45, 'ENE': 67.5,
          'E': 90, 'ESE': 112.5, 'SE': 135, 'SSE': 157.5,
          'S': 180, 'SSW': 202.5, 'SW': 225, 'WSW': 247.5,
          'W': 270, 'WNW': 292.5, 'NW': 315, 'NNW': 337.5
        };
        return directions[dir] || 0;
      };

      // æ ¹æ“šé¢¨é€Ÿåˆ¤æ–·é¢±é¢¨å¼·åº¦ä¸¦è¿”å›å°æ‡‰çš„ SVG åœ–ç¤º
      const getTyphoonIcon = (windSpeed) => {
        // ç†±å¸¶æ€§ä½æ°£å£“: < 17.2 m/s
        // è¼•åº¦é¢±é¢¨: 17.2-32.6 m/s
        // ä¸­åº¦é¢±é¢¨: 32.7-50.9 m/s
        // å¼·çƒˆé¢±é¢¨: >= 51.0 m/s

        if (windSpeed < 17.2) {
          // ç†±å¸¶æ€§ä½æ°£å£“
          return `data:image/svg+xml,${encodeURIComponent('<svg width="48" height="46" viewBox="0 0 48 46" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="24" cy="23" r="12" fill="#FF0000"/><path d="M12.3183 20.3139C12.0509 21.2427 12.587 22.2124 13.5158 22.4798C14.4446 22.7472 15.4143 22.2111 15.6817 21.2823L14 20.7981L12.3183 20.3139ZM20.5183 4.48417L21.0024 2.80249L17.6391 1.8341L17.1549 3.51578L18.8366 3.99998L20.5183 4.48417ZM14 20.7981L15.6817 21.2823L20.5183 4.48417L18.8366 3.99998L17.1549 3.51578L12.3183 20.3139L14 20.7981Z" fill="#FF0000"/><path d="M27.3183 42.3139L26.8341 43.9956L30.1975 44.964L30.6817 43.2823L29 42.7981L27.3183 42.3139ZM35.5183 26.4842C35.7857 25.5554 35.2495 24.5857 34.3208 24.3183C33.392 24.0509 32.4223 24.587 32.1549 25.5158L33.8366 26L35.5183 26.4842ZM29 42.7981L30.6817 43.2823L35.5183 26.4842L33.8366 26L32.1549 25.5158L27.3183 42.3139L29 42.7981Z" fill="#FF0000"/></svg>')}`;
        } else if (windSpeed < 32.7) {
          // è¼•åº¦é¢±é¢¨
          return `data:image/svg+xml,${encodeURIComponent('<svg width="48" height="46" viewBox="0 0 48 46" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M36 23C36 29.6274 30.6274 35 24 35C17.3726 35 12 29.6274 12 23C12 16.3726 17.3726 11 24 11C30.6274 11 36 16.3726 36 23ZM16.2406 23C16.2406 27.2854 19.7146 30.7594 24 30.7594C28.2854 30.7594 31.7594 27.2854 31.7594 23C31.7594 18.7146 28.2854 15.2406 24 15.2406C19.7146 15.2406 16.2406 18.7146 16.2406 23Z" fill="#FF0000"/><path d="M12.3183 20.3139C12.0509 21.2427 12.587 22.2124 13.5158 22.4798C14.4446 22.7472 15.4143 22.2111 15.6817 21.2823L14 20.7981L12.3183 20.3139ZM20.5183 4.48417L21.0024 2.80249L17.6391 1.8341L17.1549 3.51578L18.8366 3.99998L20.5183 4.48417ZM14 20.7981L15.6817 21.2823L20.5183 4.48417L18.8366 3.99998L17.1549 3.51578L12.3183 20.3139L14 20.7981Z" fill="#FF0000"/><path d="M27.3183 42.3139L26.8341 43.9956L30.1975 44.964L30.6817 43.2823L29 42.7981L27.3183 42.3139ZM35.5183 26.4842C35.7857 25.5554 35.2495 24.5857 34.3208 24.3183C33.392 24.0509 32.4223 24.587 32.1549 25.5158L33.8366 26L35.5183 26.4842ZM29 42.7981L30.6817 43.2823L35.5183 26.4842L33.8366 26L32.1549 25.5158L27.3183 42.3139L29 42.7981Z" fill="#FF0000"/></svg>')}`;
        } else {
          // ä¸­åº¦/å¼·çƒˆé¢±é¢¨
          return `data:image/svg+xml,${encodeURIComponent('<svg width="48" height="46" viewBox="0 0 48 46" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M42 23C42 32.9411 33.9411 41 24 41C14.0589 41 6 32.9411 6 23C6 13.0589 14.0589 5 24 5C33.9411 5 42 13.0589 42 23ZM11.5766 23C11.5766 29.8612 17.1388 35.4234 24 35.4234C30.8612 35.4234 36.4234 29.8612 36.4234 23C36.4234 16.1388 30.8612 10.5766 24 10.5766C17.1388 10.5766 11.5766 16.1388 11.5766 23Z" fill="#FF0000"/><path d="M11.7626 31.7626L10.5251 33L13 35.4749L14.2374 34.2374L13 33L11.7626 31.7626ZM35.2374 13.2374C35.9209 12.554 35.9209 11.446 35.2374 10.7626C34.554 10.0791 33.446 10.0791 32.7626 10.7626L34 12L35.2374 13.2374ZM13 33L14.2374 34.2374L35.2374 13.2374L34 12L32.7626 10.7626L11.7626 31.7626L13 33Z" fill="#FF0000"/><path d="M35.2374 31.7626L36.4749 33L34 35.4749L32.7626 34.2374L34 33L35.2374 31.7626ZM11.7626 13.2374C11.0791 12.554 11.0791 11.446 11.7626 10.7626C12.446 10.0791 13.554 10.0791 14.2374 10.7626L13 12L11.7626 13.2374ZM34 33L32.7626 34.2374L11.7626 13.2374L13 12L14.2374 10.7626L35.2374 31.7626L34 33Z" fill="#FF0000"/></svg>')}`;
        }
      };

      // åº§æ¨™å­—ä¸²è½‰æ›ç‚º [lat, lng]
      // API æ ¼å¼: "ç¶“åº¦,ç·¯åº¦" (ä¾‹å¦‚: "147.4,8.3")
      // Leaflet éœ€è¦: [ç·¯åº¦, ç¶“åº¦]
      const parseCoordinate = (coordStr) => {
        const [lng, lat] = coordStr.split(',').map(v => parseFloat(v));
        return [lat, lng]; // è¿”å› [ç·¯åº¦, ç¶“åº¦]
      };

      // ç¹ªè£½é¢¨åœˆ
      const drawWindCircle = (center, windCircle, color, opacity) => {
        if (!windCircle || !windCircle.radius) return [];

        const layers = [];
        const radius = parseFloat(windCircle.radius) * 1852; // æµ·é‡Œè½‰å…¬å°º

        if (windCircle.quadrantRadii && windCircle.quadrantRadii.radius) {
          // ç¹ªè£½å››è±¡é™é¢¨åœˆ
          const quadrants = windCircle.quadrantRadii.radius;
          quadrants.forEach(q => {
            const qRadius = parseFloat(q.value) * 1852;
            const angle = directionToDegrees(q.dir);

            // å‰µå»ºæ‰‡å½¢ (ç°¡åŒ–ç‰ˆ,ä½¿ç”¨åœ“å½¢ä»£æ›¿)
            const circle = L.circle(center, {
              radius: qRadius,
              color: color,
              fillColor: color,
              fillOpacity: opacity * 0.3,
              weight: 1,
              opacity: opacity
            });
            layers.push(circle);
          });
        } else {
          // ç¹ªè£½å®Œæ•´åœ“å½¢é¢¨åœˆ
          const circle = L.circle(center, {
            radius: radius,
            color: color,
            fillColor: color,
            fillOpacity: opacity * 0.3,
            weight: 2,
            opacity: opacity
          });
          layers.push(circle);
        }

        return layers;
      };

      // ç¹ªè£½é¢±é¢¨è·¯å¾‘
      const drawTyphoonPath = async () => {
        try {
          // æ¸…é™¤èˆŠçš„åœ–å±¤
          typhoonLayers.clearLayers();

          // ç²å–é¢±é¢¨è­¦å ±è³‡æ–™
          console.log('ğŸŒ€ é–‹å§‹ç²å–é¢±é¢¨è­¦å ±è³‡æ–™...');
          updateDebugInfo('ğŸ”„ æ­£åœ¨ç²å–é¢±é¢¨è³‡æ–™...');

          const response = await fetch(`${window.location.origin}/api/typhoon/warning`);
          console.log('ğŸ“¡ API å›æ‡‰ç‹€æ…‹:', response.status);

          if (!response.ok) {
            const errorMsg = `âš ï¸ ç„¡æ³•å–å¾—é¢±é¢¨è­¦å ±è³‡æ–™\nç‹€æ…‹ç¢¼: ${response.status}`;
            console.warn(errorMsg);
            updateDebugInfo(errorMsg);
            return;
          }

          const data = await response.json();
          console.log('ğŸ“¦ æ”¶åˆ°çš„è³‡æ–™:', data);

          if (data.error) {
            const errorMsg = `âŒ API éŒ¯èª¤:\n${data.error}`;
            console.error(errorMsg);
            updateDebugInfo(errorMsg);
            return;
          }

          // æ­£ç¢ºçš„è³‡æ–™çµæ§‹è·¯å¾‘
          const typhoons = data.records?.tropicalCyclones?.tropicalCyclone || [];

          if (typhoons.length === 0) {
            const infoMsg = 'â„¹ï¸ ç›®å‰ç„¡é¢±é¢¨è­¦å ±è³‡æ–™\n(å¯èƒ½æ²’æœ‰é¢±é¢¨æˆ–è¶…å‡ºæŸ¥è©¢æ™‚é–“ç¯„åœ)';
            console.log(infoMsg);
            updateDebugInfo(infoMsg);
            return;
          }

          console.log(`âœ… æ‰¾åˆ° ${typhoons.length} å€‹é¢±é¢¨è³‡æ–™`);

          let debugInfo = `âœ… æ‰¾åˆ° ${typhoons.length} å€‹é¢±é¢¨\n`;

          // è™•ç†æ¯å€‹é¢±é¢¨
          typhoons.forEach((typhoonInfo, typhoonIndex) => {
            const typhoonName = typhoonInfo.cwaTyphoonName || `é¢±é¢¨ ${typhoonInfo.cwaTdNo}`;

            debugInfo += `\né¢±é¢¨: ${typhoonName} (${typhoonInfo.typhoonName})\n`;

            // æ”¶é›†æ‰€æœ‰è·¯å¾‘é»
            const analysisPoints = [];
            const forecastPoints = [];

            // è™•ç†åˆ†æè³‡æ–™(å¯¦éš›è·¯å¾‘)
            if (typhoonInfo.analysisData && typhoonInfo.analysisData.fix) {
              typhoonInfo.analysisData.fix.forEach((fix, idx) => {
                const coord = parseCoordinate(fix.coordinate);
                analysisPoints.push({
                  coord: coord,
                  time: new Date(fix.fixTime),
                  windSpeed: parseFloat(fix.maxWindSpeed),
                  pressure: parseFloat(fix.pressure),
                  movingDir: fix.movingDirection,
                  circle15: fix.circleOf15Ms,
                  circle25: fix.circleOf25Ms
                });
              });
            }

            // è™•ç†é å ±è³‡æ–™(é æ¸¬è·¯å¾‘)
            if (typhoonInfo.forecastData && typhoonInfo.forecastData.fix) {
              typhoonInfo.forecastData.fix.forEach((fix, idx) => {
                const coord = parseCoordinate(fix.coordinate);
                forecastPoints.push({
                  coord: coord,
                  tau: parseInt(fix.tau),
                  windSpeed: fix.maxWindSpeed ? parseFloat(fix.maxWindSpeed) : null,
                  pressure: parseFloat(fix.pressure),
                  radius70: parseFloat(fix.radiusOf70PercentProbability) * 1852
                });
              });
            }

            // ç¹ªè£½å¯¦éš›è·¯å¾‘
            if (analysisPoints.length > 0) {
              const pathCoords = analysisPoints.map(p => p.coord);
              const pathLine = L.polyline(pathCoords, {
                color: '#FF0000',
                weight: 3,
                opacity: 0.8
              }).bindPopup(`${typhoonName} - å¯¦éš›è·¯å¾‘`);
              typhoonLayers.addLayer(pathLine);

              // ç¹ªè£½è·¯å¾‘é»å’Œé¢¨åœˆ
              analysisPoints.forEach((point, idx) => {
                // ä½¿ç”¨è‡ªå®šç¾©åœ–ç¤ºæ¨™è¨˜
                const icon = L.icon({
                  iconUrl: getTyphoonIcon(point.windSpeed),
                  iconSize: [24, 24],
                  iconAnchor: [12, 12],
                  popupAnchor: [0, -12]
                });

                const marker = L.marker(point.coord, { icon: icon })
                  .bindPopup(`
                    <strong>${typhoonName}</strong><br>
                    æ™‚é–“: ${point.time.toLocaleString('zh-TW')}<br>
                    é¢¨é€Ÿ: ${point.windSpeed} m/s<br>
                    æ°£å£“: ${point.pressure} hPa<br>
                    ç§»å‹•æ–¹å‘: ${point.movingDir}
                  `);
                typhoonLayers.addLayer(marker);

                // åªåœ¨æœ€æ–°ä½ç½®ç¹ªè£½é¢¨åœˆ
                if (idx === analysisPoints.length - 1) {
                  // 7ç´šé¢¨åœˆ (15 m/s)
                  if (point.circle15) {
                    const circles15 = drawWindCircle(point.coord, point.circle15, '#FFFF00', 0.6);
                    circles15.forEach(c => typhoonLayers.addLayer(c));
                  }

                  // 10ç´šé¢¨åœˆ (25 m/s)
                  if (point.circle25) {
                    const circles25 = drawWindCircle(point.coord, point.circle25, '#FF6600', 0.8);
                    circles25.forEach(c => typhoonLayers.addLayer(c));
                  }
                }
              });
            }

            // ç¹ªè£½é æ¸¬è·¯å¾‘ - é€£æ¥æœ€å¾Œä¸€å€‹åˆ†æé»
            if (forecastPoints.length > 0) {
              // å¦‚æœæœ‰åˆ†æè³‡æ–™,å°‡é æ¸¬è·¯å¾‘èˆ‡æœ€å¾Œä¸€å€‹åˆ†æé»é€£æ¥
              const forecastCoords = forecastPoints.map(p => p.coord);
              if (analysisPoints.length > 0) {
                const lastAnalysisPoint = analysisPoints[analysisPoints.length - 1].coord;
                forecastCoords.unshift(lastAnalysisPoint); // åœ¨é æ¸¬è·¯å¾‘å‰åŠ å…¥æœ€å¾Œä¸€å€‹åˆ†æé»
              }

              const forecastLine = L.polyline(forecastCoords, {
                color: '#0000FF',
                weight: 2,
                opacity: 0.6,
                dashArray: '10, 10'
              }).bindPopup(`${typhoonName} - é æ¸¬è·¯å¾‘`);
              typhoonLayers.addLayer(forecastLine);

              // ç¹ªè£½é æ¸¬é»å’Œä¸ç¢ºå®šæ€§åœ“
              forecastPoints.forEach((point, idx) => {
                const marker = L.circleMarker(point.coord, {
                  radius: 5,
                  fillColor: '#0000FF',
                  color: '#FFFFFF',
                  weight: 2,
                  opacity: 0.8,
                  fillOpacity: 0.6
                }).bindPopup(`
                  <strong>${typhoonName} - é æ¸¬</strong><br>
                  é å ±æ™‚è·: ${point.tau} å°æ™‚<br>
                  ${point.windSpeed ? `é¢¨é€Ÿ: ${point.windSpeed} m/s<br>` : ''}
                  æ°£å£“: ${point.pressure} hPa
                `);
                typhoonLayers.addLayer(marker);

                // 70%æ©Ÿç‡åœ“
                if (point.radius70 > 0) {
                  const uncertainty = L.circle(point.coord, {
                    radius: point.radius70,
                    color: '#0000FF',
                    fillColor: '#0000FF',
                    fillOpacity: 0.1,
                    weight: 1,
                    opacity: 0.3,
                    dashArray: '5, 5'
                  });
                  typhoonLayers.addLayer(uncertainty);
                }
              });
            }

            debugInfo += '\n';
          });

          // æ›´æ–°èª¿è©¦é¢æ¿
          updateDebugInfo(debugInfo);

        } catch (error) {
          const errorMsg = `âŒ é¢±é¢¨è·¯å¾‘é¡¯ç¤ºéŒ¯èª¤:\n${error.message}\n\n${error.stack}`;
          console.error('é¢±é¢¨è·¯å¾‘é¡¯ç¤ºéŒ¯èª¤:', error);
          updateDebugInfo(errorMsg);
        }
      };

      // åˆå§‹åŒ–ä¸¦è¿”å›æ§åˆ¶å‡½æ•¸
      return async () => {
        if (!isInitialized) {
          typhoonLayers.addTo(map);
          isInitialized = true;
        }
        await drawTyphoonPath();

        // æ¯5åˆ†é˜æ›´æ–°ä¸€æ¬¡é¢±é¢¨è·¯å¾‘
        setInterval(drawTyphoonPath, 5 * 60 * 1000);
      };
    })();

    // å•Ÿå‹•é¢±é¢¨è·¯å¾‘é¡¯ç¤º
    initializeTyphoonPathDisplay();
  </script>
</body>

</html>